<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CKEditor in Shadow DOM - POC Test Page</title>
    <script src="https://cdn.ckeditor.com/ckeditor5/41.0.0/classic/ckeditor.js"></script>
    <link rel="stylesheet" href="https://cdn.ckeditor.com/ckeditor5/41.0.0/classic/ckeditor.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #0066cc;
            padding-bottom: 10px;
        }
        h2 {
            color: #0066cc;
            margin-top: 30px;
        }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 8px;
        }
        .shadow-host {
            min-height: 400px;
            padding: 20px;
            background: #fafafa;
            border: 2px solid #0066cc;
            border-radius: 4px;
        }
        .debug-info {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background: #0052a3;
        }
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.shadow {
            background: #4caf50;
            color: white;
        }
        .status.normal {
            background: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ CKEditor in Shadow DOM - POC Test Page</h1>
        
        <div class="info-box">
            <strong>Purpose:</strong> This page demonstrates CKEditor 5 running inside a Shadow DOM for testing Low Code Automation compatibility.
            <br><br>
            <strong>Test Focus:</strong> Element selection, event recording, and playback within Shadow DOM boundaries.
        </div>

        <div class="test-section">
            <h2>Test 1: CKEditor in Shadow DOM <span class="status shadow">‚úì Shadow DOM</span></h2>
            <p>This editor is wrapped in a Web Component with Shadow DOM (open mode)</p>
            <ckeditor-shadow-wrapper id="shadow-editor-1"></ckeditor-shadow-wrapper>
            
            <div class="debug-info">
                <strong>Debug Info:</strong><br>
                Element: &lt;ckeditor-shadow-wrapper&gt;<br>
                Shadow Root: Open<br>
                Selector Path: ckeditor-shadow-wrapper ‚Üí #shadow-root ‚Üí .ck-editor
            </div>
        </div>

        <div class="test-section">
            <h2>Test 2: Regular CKEditor (No Shadow DOM) <span class="status normal">‚ö† Regular DOM</span></h2>
            <p>This is a standard CKEditor for comparison</p>
            <div id="regular-editor-1"></div>
            
            <div class="debug-info">
                <strong>Debug Info:</strong><br>
                Element: &lt;div id="regular-editor-1"&gt;<br>
                Shadow Root: None<br>
                Selector Path: #regular-editor-1 ‚Üí .ck-editor
            </div>
        </div>

        <div class="test-section">
            <h2>Test 3: Multiple CKEditors in Shadow DOM <span class="status shadow">‚úì Shadow DOM</span></h2>
            <p>Two separate editors in different shadow roots to test unique identification</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h3>Editor A</h3>
                    <ckeditor-shadow-wrapper id="shadow-editor-2"></ckeditor-shadow-wrapper>
                </div>
                <div>
                    <h3>Editor B</h3>
                    <ckeditor-shadow-wrapper id="shadow-editor-3"></ckeditor-shadow-wrapper>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ÔøΩ Event Debugging Panel</h2>
            <p>This panel shows real-time event capture to debug LCA recording issues:</p>
            <button onclick="clearDebugPanel()">Clear Events</button>
            <button onclick="toggleDebugPanel()">Toggle Panel</button>
            <div id="debug-panel-container" style="margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 4px; max-height: 300px; overflow-y: auto;">
                <strong>Recent Events (newest first):</strong>
                <div style="margin-top: 10px; font-family: monospace; font-size: 11px;">
                    <div style="padding: 5px; background: #e8f5e9; margin-bottom: 2px;">üü¢ Green = Shadow DOM editor events</div>
                    <div style="padding: 5px; background: #e3f2fd; margin-bottom: 10px;">üîµ Blue = Regular DOM editor events</div>
                </div>
                <div id="debug-events"></div>
            </div>
        </div>

        <div class="test-section">
            <h2>ÔøΩüîç Verification Tools</h2>
            <p>Use these buttons to verify Shadow DOM implementation:</p>
            <button onclick="checkShadowDOM()">Check Shadow DOM Status</button>
            <button onclick="inspectElements()">Inspect Elements</button>
            <button onclick="getEditorContent()">Get All Editor Content</button>
            <div id="verification-output" style="margin-top: 15px; padding: 15px; background: #f5f5f5; border-radius: 4px; display: none;">
                <pre id="verification-result"></pre>
            </div>
        </div>
    </div>

    <script>
        // Web Component that wraps CKEditor in Shadow DOM
        class CKEditorShadowWrapper extends HTMLElement {
            constructor() {
                super();
                // Create shadow root (open mode so it can be inspected)
                this.attachShadow({ mode: 'open' });
            }

            connectedCallback() {
                // Create container for CKEditor inside shadow root
                const container = document.createElement('div');
                container.id = 'editor-container';
                container.style.minHeight = '300px';
                
                // Copy all CKEditor stylesheets from main document to shadow DOM
                this.copyCKEditorStyles();
                
                // Add custom styles
                const style = document.createElement('style');
                style.textContent = `
                    #editor-container {
                        padding: 10px;
                        background: white;
                        border-radius: 4px;
                    }
                    
                    /* Ensure CKEditor content is visible */
                    .ck.ck-editor__main > .ck-editor__editable {
                        min-height: 200px;
                    }
                `;
                
                this.shadowRoot.appendChild(style);
                this.shadowRoot.appendChild(container);

                // Initialize CKEditor after a short delay to ensure styles are ready
                setTimeout(() => {
                    this.initializeCKEditor(container);
                }, 100);
            }

            copyCKEditorStyles() {
                // Get all stylesheets from the main document
                const mainStyleSheets = Array.from(document.styleSheets);
                
                mainStyleSheets.forEach(sheet => {
                    try {
                        // Check if stylesheet is from CKEditor CDN or has CK rules
                        const href = sheet.href || '';
                        if (href.includes('ckeditor') || this.hasCKEditorRules(sheet)) {
                            // Create a link element to load the stylesheet
                            if (sheet.href) {
                                const link = document.createElement('link');
                                link.rel = 'stylesheet';
                                link.href = sheet.href;
                                this.shadowRoot.appendChild(link);
                            } else {
                                // For inline styles, copy the rules
                                this.copyStyleRules(sheet);
                            }
                        }
                    } catch (e) {
                        // CORS or other access issues - ignore
                        console.debug('Could not access stylesheet:', e);
                    }
                });
            }

            hasCKEditorRules(sheet) {
                try {
                    const rules = sheet.cssRules || sheet.rules;
                    if (!rules) return false;
                    
                    for (let rule of rules) {
                        if (rule.selectorText && rule.selectorText.includes('.ck')) {
                            return true;
                        }
                    }
                } catch (e) {
                    // Access denied
                }
                return false;
            }

            copyStyleRules(sheet) {
                try {
                    const rules = sheet.cssRules || sheet.rules;
                    if (!rules) return;
                    
                    const style = document.createElement('style');
                    let cssText = '';
                    
                    for (let rule of rules) {
                        cssText += rule.cssText + '\n';
                    }
                    
                    style.textContent = cssText;
                    this.shadowRoot.appendChild(style);
                } catch (e) {
                    console.debug('Could not copy style rules:', e);
                }
            }

            initializeCKEditor(container) {
                // Initialize CKEditor inside shadow DOM
                ClassicEditor
                    .create(container, {
                        placeholder: 'Start typing in Shadow DOM editor...',
                        toolbar: [
                            'heading', '|',
                            'bold', 'italic', 'underline', 'strikethrough', '|',
                            'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor', '|',
                            'bulletedList', 'numberedList', '|',
                            'alignment', '|',
                            'link', 'imageUpload', 'blockQuote', 'insertTable', '|',
                            'undo', 'redo'
                        ]
                    })
                    .then(editor => {
                        this.editor = editor;
                        console.log('‚úÖ CKEditor initialized in Shadow DOM:', this.id);
                        
                        // Add debug event listeners to track event firing
                        this.setupEventDebugging();
                    })
                    .catch(error => {
                        console.error('Error initializing CKEditor in Shadow DOM:', error);
                    });
            }

            setupEventDebugging() {
                // Find the contenteditable element
                const editable = this.shadowRoot.querySelector('.ck-editor__editable');
                if (!editable) {
                    console.warn('Could not find contenteditable element for debugging');
                    return;
                }

                console.log('üîç Setting up event debugging for:', this.id);
                console.log('  contentEditable:', editable.contentEditable);
                console.log('  tagName:', editable.tagName);

                // Track all relevant events
                const events = ['input', 'beforeinput', 'keydown', 'keyup', 'textInput', 'compositionstart', 'compositionupdate', 'compositionend'];
                
                events.forEach(eventType => {
                    // Capture phase listener on the contenteditable element
                    editable.addEventListener(eventType, (e) => {
                        this.logEvent('EDITABLE', eventType, e);
                    }, true);

                    // Bubble phase listener
                    editable.addEventListener(eventType, (e) => {
                        this.logEvent('EDITABLE-BUBBLE', eventType, e);
                    }, false);
                });

                // Also listen on shadow root
                events.forEach(eventType => {
                    this.shadowRoot.addEventListener(eventType, (e) => {
                        this.logEvent('SHADOW-ROOT', eventType, e);
                    }, true);
                });

                // Listen for CKEditor's internal model changes
                this.editor.model.document.on('change:data', () => {
                    console.log('üìù CKEditor model changed');
                });
            }

            logEvent(source, type, event) {
                const eventInfo = {
                    source,
                    type,
                    target: event.target.tagName,
                    contentEditable: event.target.contentEditable,
                    defaultPrevented: event.defaultPrevented,
                    cancelBubble: event.cancelBubble,
                    bubbles: event.bubbles,
                    composed: event.composed
                };

                if (type.includes('input')) {
                    eventInfo.data = event.data;
                    eventInfo.inputType = event.inputType;
                }

                console.log(`üéØ [${this.id}] ${source} ‚Üí ${type}:`, eventInfo);
                
                // Add to debug panel
                this.updateDebugPanel(eventInfo);
            }

            updateDebugPanel(eventInfo) {
                const debugPanel = document.getElementById('debug-events');
                if (debugPanel) {
                    const entry = document.createElement('div');
                    entry.style.cssText = 'padding: 5px; margin: 2px 0; background: #e8f5e9; border-left: 3px solid #4caf50; font-size: 12px;';
                    entry.textContent = `${new Date().toLocaleTimeString()}.${new Date().getMilliseconds()} | ${eventInfo.source} ‚Üí ${eventInfo.type} | bubbles: ${eventInfo.bubbles} | prevented: ${eventInfo.defaultPrevented}`;
                    debugPanel.insertBefore(entry, debugPanel.firstChild);
                    
                    // Keep only last 20 events
                    while (debugPanel.children.length > 20) {
                        debugPanel.removeChild(debugPanel.lastChild);
                    }
                }
            }

            getContent() {
                return this.editor ? this.editor.getData() : '';
            }
        }

        // Register the custom element
        customElements.define('ckeditor-shadow-wrapper', CKEditorShadowWrapper);

        // Initialize regular CKEditor (no shadow DOM)
        let regularEditor;
        ClassicEditor
            .create(document.querySelector('#regular-editor-1'), {
                placeholder: 'Start typing in regular editor...',
                toolbar: [
                    'heading', '|',
                    'bold', 'italic', 'underline', 'strikethrough', '|',
                    'fontSize', 'fontFamily', 'fontColor', 'fontBackgroundColor', '|',
                    'bulletedList', 'numberedList', '|',
                    'alignment', '|',
                    'link', 'imageUpload', 'blockQuote', 'insertTable', '|',
                    'undo', 'redo'
                ]
            })
            .then(editor => {
                regularEditor = editor;
                console.log('‚úÖ Regular CKEditor initialized');
                
                // Add same debugging for regular editor
                setupRegularEditorDebugging(editor);
            })
            .catch(error => {
                console.error('Error initializing regular CKEditor:', error);
            });

        // Setup debugging for regular editor (same logic as shadow DOM version)
        function setupRegularEditorDebugging(editor) {
            const editable = document.querySelector('#regular-editor-1 .ck-editor__editable');
            if (!editable) {
                console.warn('Could not find regular contenteditable element for debugging');
                return;
            }

            console.log('üîç Setting up event debugging for regular editor');
            console.log('  contentEditable:', editable.contentEditable);
            console.log('  tagName:', editable.tagName);

            const events = ['input', 'beforeinput', 'keydown', 'keyup', 'textInput', 'compositionstart', 'compositionupdate', 'compositionend'];
            
            events.forEach(eventType => {
                // Capture phase
                editable.addEventListener(eventType, (e) => {
                    logRegularEvent('REGULAR-EDITABLE', eventType, e);
                }, true);

                // Bubble phase
                editable.addEventListener(eventType, (e) => {
                    logRegularEvent('REGULAR-BUBBLE', eventType, e);
                }, false);
            });

            // Listen on document level too
            events.forEach(eventType => {
                document.addEventListener(eventType, (e) => {
                    if (e.target.closest('#regular-editor-1')) {
                        logRegularEvent('DOCUMENT-LEVEL', eventType, e);
                    }
                }, true);
            });

            // CKEditor model changes
            editor.model.document.on('change:data', () => {
                console.log('üìù Regular CKEditor model changed');
            });
        }

        function logRegularEvent(source, type, event) {
            const eventInfo = {
                source,
                type,
                target: event.target.tagName,
                contentEditable: event.target.contentEditable,
                defaultPrevented: event.defaultPrevented,
                cancelBubble: event.cancelBubble,
                bubbles: event.bubbles,
                composed: event.composed
            };

            if (type.includes('input')) {
                eventInfo.data = event.data;
                eventInfo.inputType = event.inputType;
            }

            console.log(`üéØ [REGULAR] ${source} ‚Üí ${type}:`, eventInfo);
            
            // Add to debug panel
            const debugPanel = document.getElementById('debug-events');
            if (debugPanel) {
                const entry = document.createElement('div');
                entry.style.cssText = 'padding: 5px; margin: 2px 0; background: #e3f2fd; border-left: 3px solid #2196f3; font-size: 12px;';
                entry.textContent = `${new Date().toLocaleTimeString()}.${new Date().getMilliseconds()} | ${eventInfo.source} ‚Üí ${eventInfo.type} | bubbles: ${eventInfo.bubbles} | prevented: ${eventInfo.defaultPrevented}`;
                debugPanel.insertBefore(entry, debugPanel.firstChild);
                
                while (debugPanel.children.length > 20) {
                    debugPanel.removeChild(debugPanel.lastChild);
                }
            }
        }

        // Debug panel helper functions
        function clearDebugPanel() {
            const debugPanel = document.getElementById('debug-events');
            if (debugPanel) {
                debugPanel.innerHTML = '';
                console.log('üßπ Debug panel cleared');
            }
        }

        function toggleDebugPanel() {
            const container = document.getElementById('debug-panel-container');
            if (container) {
                container.style.display = container.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Verification functions
        function checkShadowDOM() {
            const output = document.getElementById('verification-output');
            const result = document.getElementById('verification-result');
            
            const shadowWrappers = document.querySelectorAll('ckeditor-shadow-wrapper');
            let info = 'Shadow DOM Status Check:\n\n';
            
            shadowWrappers.forEach((wrapper, index) => {
                info += `Editor ${index + 1} (${wrapper.id}):\n`;
                info += `  - Has Shadow Root: ${!!wrapper.shadowRoot}\n`;
                info += `  - Shadow Mode: ${wrapper.shadowRoot ? 'open' : 'N/A'}\n`;
                info += `  - Shadow Children: ${wrapper.shadowRoot ? wrapper.shadowRoot.children.length : 0}\n`;
                
                if (wrapper.shadowRoot) {
                    const ckEditor = wrapper.shadowRoot.querySelector('.ck-editor');
                    info += `  - CKEditor Found: ${!!ckEditor}\n`;
                }
                info += '\n';
            });
            
            result.textContent = info;
            output.style.display = 'block';
        }

        function inspectElements() {
            const output = document.getElementById('verification-output');
            const result = document.getElementById('verification-result');
            
            let info = 'Element Inspection:\n\n';
            
            // Check shadow editors
            const shadowWrappers = document.querySelectorAll('ckeditor-shadow-wrapper');
            shadowWrappers.forEach((wrapper, index) => {
                info += `Shadow Editor ${index + 1}:\n`;
                info += `  Selector: ${wrapper.tagName.toLowerCase()}#${wrapper.id}\n`;
                
                if (wrapper.shadowRoot) {
                    const buttons = wrapper.shadowRoot.querySelectorAll('button');
                    info += `  Buttons in Shadow DOM: ${buttons.length}\n`;
                    
                    if (buttons.length > 0) {
                        info += `  First button aria-label: ${buttons[0].getAttribute('aria-label') || 'N/A'}\n`;
                    }
                    
                    const contentEditable = wrapper.shadowRoot.querySelector('[contenteditable]');
                    info += `  Editable area found: ${!!contentEditable}\n`;
                }
                info += '\n';
            });
            
            // Check regular editor
            const regularEditorEl = document.querySelector('#regular-editor-1');
            if (regularEditorEl) {
                info += 'Regular Editor:\n';
                info += `  Selector: #regular-editor-1\n`;
                const ckEditor = regularEditorEl.querySelector('.ck-editor');
                info += `  CKEditor found: ${!!ckEditor}\n`;
                
                if (ckEditor) {
                    const buttons = ckEditor.querySelectorAll('button');
                    info += `  Buttons: ${buttons.length}\n`;
                }
            }
            
            result.textContent = info;
            output.style.display = 'block';
        }

        function getEditorContent() {
            const output = document.getElementById('verification-output');
            const result = document.getElementById('verification-result');
            
            let info = 'Editor Content:\n\n';
            
            // Get shadow editor content
            const shadowWrappers = document.querySelectorAll('ckeditor-shadow-wrapper');
            shadowWrappers.forEach((wrapper, index) => {
                const content = wrapper.getContent();
                info += `Shadow Editor ${index + 1} (${wrapper.id}):\n`;
                info += content || '  (empty)\n';
                info += '\n---\n\n';
            });
            
            // Get regular editor content
            if (regularEditor) {
                info += 'Regular Editor:\n';
                info += regularEditor.getData() || '  (empty)\n';
            }
            
            result.textContent = info;
            output.style.display = 'block';
        }

        // Add window-level listeners to simulate LCA's behavior
        function setupWindowLevelDebugging() {
            console.log('ü™ü Setting up window-level event listeners (simulating LCA)');
            
            const events = ['input', 'keydown', 'keyup'];
            events.forEach(eventType => {
                window.addEventListener(eventType, (e) => {
                    // Check if event is from CKEditor
                    const isCKEditor = e.target.closest('.ck-editor') || e.target.classList.contains('ck-editor__editable');
                    if (isCKEditor) {
                        console.log(`ü™ü WINDOW-LEVEL (capture) ‚Üí ${eventType}:`, {
                            target: e.target.tagName,
                            contentEditable: e.target.contentEditable,
                            className: e.target.className,
                            defaultPrevented: e.defaultPrevented,
                            propagationStopped: e.cancelBubble
                        });
                    }
                }, true); // Capture phase, like LCA
            });
        }

        // Auto-run initial check after page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('üéØ POC Test Page Ready!');
                console.log('Run checkShadowDOM() in console to verify Shadow DOM setup');
                console.log('üìä Debug panel shows real-time event capture');
                
                // Setup window-level debugging
                setupWindowLevelDebugging();
            }, 1000);
        });
    </script>
</body>
</html>
